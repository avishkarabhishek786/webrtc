<div class="container">

    <div id="buttons">
        <button id="startButton">Start</button>
        <button id="sendButton" disabled>Send</button>
        <button id="closeButton" disabled>Stop</button>
    </div>

    <!-- <div id="sendReceive">
        <div id="send">
            <h2>Send</h2>
            <textarea id="dataChannelSend" disabled placeholder="Press Start, enter some text, then press Send."></textarea>
        </div>
        <div id="receive">
            <h2>Receive</h2>
            <textarea id="dataChannelReceive" disabled></textarea>
        </div>
    </div> -->

    <div>
        <label for="myName">Your Name:</label>
        <input type="text" id="myName">

        <label for="dataChannelSend">Message:</label>
        <textarea id="dataChannelSend" cols="12" rows="5"></textarea>

        <input type="submit" id="sendMessage">

        <div id="dataChannelReceive">Mesage Output: <br></div>

        <div id="signalling_area">Signalling messages: <br></div>
    </div>

</div>

<script src="/socket.io/socket.io.js"></script>
<script>
    'use strict';

    var socket = io();

    let localConnection;
    let remoteConnection;
    let sendChannel;
    let receiveChannel;
    const myName = document.querySelector("#myName")
    const dataChannelSend = document.querySelector('textarea#dataChannelSend');
    const dataChannelReceive = document.querySelector('div#dataChannelReceive');
    const startButton = document.querySelector('button#startButton');
    const sendButton = document.querySelector('button#sendButton');
    const closeButton = document.querySelector('button#closeButton');
    var ROOM = "chat";
    var SIGNAL_ROOM = "signal_room";

    socket.on('connect', function () {
        console.log('datachannel socketio connected to server');

        startButton.onclick = createConnection;
        sendButton.onclick = sendData;
        closeButton.onclick = closeDataChannels;

        socket.emit('ready', {
            "chat_room": ROOM,
            "signal_room": SIGNAL_ROOM
        }, function (err) {
            if (err) {
                alert(err);
            }
            console.log('No error');
        });

    });

    socket.on('disconnect', function () {
        console.log('Disconnected to server!');
    });

    socket.emit('signal', {
        "type": "user_here",
        "message": "Are you ready for the chat?",
        "room": SIGNAL_ROOM
    })

    socket.on('signaling_message', function (data) {
        displaySignalMessage("Signal received: " + data.type);

        //Setup the RTC Peer Connection object
        if (!remoteConnection || !localConnection)
            createConnection();

        if (data.type != "user_here") {
            var message = JSON.parse(data.message);
            if (message.sdp) {
                remoteConnection.setRemoteDescription(new RTCSessionDescription(message.sdp), function () {
                    // if we received an offer, we need to answer
                    if (remoteConnection.remoteDescription.type == 'offer') {
                        remoteConnection.createAnswer(sendLocalDesc, logError);
                    }
                }, logError);
            } else {
                remoteConnection.addIceCandidate(new RTCIceCandidate(message.candidate));
            }
        }

    });

    function enableStartButton() {
        startButton.disabled = false;
    }

    function disableSendButton() {
        sendButton.disabled = true;
    }

    function createConnection() {
        myName.placeholder = '';
        dataChannelSend.placeholder = '';
        const servers = {
            iceServers: [
                {url: 'stun:stun.l.google.com:19302'},
                {url: 'stun:stun1.l.google.com:19302'},
                {url: 'stun:stun2.l.google.com:19302'},
                {url: 'stun:stun3.l.google.com:19302'},
                {url: 'stun:stun4.l.google.com:19302'}
            ]
        };

        const dataChannelOptions = {
            ordered: false,
            maxPacketLifeTime: 1000 // ms
        }

        window.localConnection = localConnection = new RTCPeerConnection(servers, null);
        console.log('Created local peer connection object localConnection');

        sendChannel = localConnection.createDataChannel('sendDataChannel', dataChannelOptions);
        console.log('Created send data channel');

        localConnection.onicecandidate = e => {
            onIceCandidate(localConnection, e);
        };
        sendChannel.onopen = onSendChannelStateChange;
        sendChannel.onclose = onSendChannelStateChange;

        window.remoteConnection = remoteConnection = new RTCPeerConnection(servers, null);
        console.log('Created remote peer connection object remoteConnection');

        remoteConnection.onicecandidate = e => {
            onIceCandidate(remoteConnection, e);
        };
        remoteConnection.ondatachannel = receiveChannelCallback;

        localConnection.createOffer().then(
            gotDescription1,
            onCreateSessionDescriptionError
        );
        startButton.disabled = true;
        closeButton.disabled = false;
    }

    function onCreateSessionDescriptionError(error) {
        console.log('Failed to create session description: ' + error.toString());
    }

    function sendData() {
        const data = myName.value + ': ' + dataChannelSend.value;
        sendChannel.send(data);
        console.log('Sent Data: ' + data);
    }

    function closeDataChannels() {
        console.log('Closing data channels');
        sendChannel.close();
        console.log('Closed data channel with label: ' + sendChannel.label);
        receiveChannel.close();
        console.log('Closed data channel with label: ' + receiveChannel.label);
        localConnection.close();
        remoteConnection.close();
        localConnection = null;
        remoteConnection = null;
        console.log('Closed peer connections');
        startButton.disabled = false;
        sendButton.disabled = true;
        closeButton.disabled = true;
        myName.value = '';
        dataChannelSend.value = '';
        //dataChannelReceive.value = '';
        dataChannelSend.disabled = true;
        disableSendButton();
        enableStartButton();
    }

    function gotDescription1(desc) {
        localConnection.setLocalDescription(desc).then(() => onSetLocalSuccess(localConnection),
            onSetSessionDescriptionError);
        console.log(`Offer from localConnection\n${desc.sdp}`);
        remoteConnection.setRemoteDescription(desc).then(() => onSetRemoteSuccess(remoteConnection),
            onSetSessionDescriptionError);
        remoteConnection.createAnswer().then(
            gotDescription2,
            onCreateSessionDescriptionError
        );
    }

    function gotDescription2(desc) {
        remoteConnection.setLocalDescription(desc).then(() => onSetLocalSuccess(remoteConnection),
            onSetSessionDescriptionError);
        console.log(`Answer from remoteConnection\n${desc.sdp}`);
        localConnection.setRemoteDescription(desc).then(() => onSetRemoteSuccess(localConnection),
            onSetSessionDescriptionError);
    }

    function onSetLocalSuccess(pc) {
        socket.emit('signal', {
            "type": "SDP",
            "message": JSON.stringify({
                'sdp': pc.localDescription
            }),
            "room": SIGNAL_ROOM
        }, logError);
        console.log(`${getName(pc)} setLocalDescription complete **********`);
    }

    function onSetRemoteSuccess(pc) {
        socket.emit('signal', {
            "type": "SDP",
            "message": JSON.stringify({
                'sdp': pc.remoteDescription
            }),
            "room": SIGNAL_ROOM
        }, logError);
        console.log(`${getName(pc)} setRemoteDescription complete ********************`);
    }

    function onCreateSessionDescriptionError(error) {
        console.log(`Failed to create session description: ${error.toString()}`);
    }

    function onSetSessionDescriptionError(error) {
        console.log(`Failed to set session description: ${error.toString()}`);
    }

    function getOtherPc(pc) {
        return (pc === localConnection) ? remoteConnection : localConnection;
    }

    function getName(pc) {
        return (pc === localConnection) ? 'localPeerConnection' : 'remotePeerConnection';
    }

    function onIceCandidate(pc, event) {
        getOtherPc(pc)
            .addIceCandidate(event.candidate)
            .then(
                () => onAddIceCandidateSuccess(pc, event),
                err => onAddIceCandidateError(pc, err)
            );
        //console.log(pc);    
        console.log(`${getName(pc)} ICE candidate: ${event.candidate ? event.candidate.candidate : '(null)'}`);
    }

    function onAddIceCandidateSuccess(pc, evt) {
        socket.emit('signal', {
            "type": "ice candidate",
            "message": JSON.stringify({
                'candidate': evt.candidate
            }),
            "room": SIGNAL_ROOM
        });
        console.log('AddIceCandidate success.');
    }

    function onAddIceCandidateError(error) {
        console.log(`Failed to add Ice Candidate: ${error.toString()}`);
    }

    function receiveChannelCallback(event) {
        console.log('Receive Channel Callback');
        console.log(event.channel);
        receiveChannel = event.channel;
        receiveChannel.onmessage = onReceiveMessageCallback;
        receiveChannel.onopen = onReceiveChannelStateChange;
        receiveChannel.onclose = onReceiveChannelStateChange;
        //sendChannel.onmessage = onReceiveMessageCallback;
    }

    function onReceiveMessageCallback(event) {
        console.log('Received Message');
        //dataChannelReceive.value = event.data;
        displayMessage("From DataChannel1: " + event.data)
        //displayMessage(data.author + ': ' + data.message)
    }

    function onSendChannelStateChange() {
        const readyState = sendChannel.readyState;
        console.log('Send channel state is: ' + readyState);
        if (readyState === 'open') {
            myName.disabled = false;
            dataChannelSend.disabled = false;
            dataChannelSend.focus();
            sendButton.disabled = false;
            closeButton.disabled = false;
            sendChannel.onmessage = onReceiveMessageCallback;
        } else {
            myName.disabled = true;
            dataChannelSend.disabled = true;
            sendButton.disabled = true;
            closeButton.disabled = true;
        }
    }

    function onReceiveChannelStateChange() {
        const readyState = receiveChannel.readyState;
        console.log(`Receive channel state is: ${readyState}`);
    }

    function receiveDataChannelMessage(event) {
        displaySignalMessage("Incoming Message");
        displayMessage("From DataChannel: " + event.data);
    }

    function logError(error) {
        displaySignalMessage(error.name + ': ' + error.message);
    }

    function displayMessage(message) {
        dataChannelReceive.innerHTML = dataChannelReceive.innerHTML + "<br>" + message;
    }

    function displaySignalMessage(message) {
        signallingArea.innerHTML = signallingArea.innerHTML + "<br>" + message;
    }

    // socket.on('message', function (data) {
    //     displayMessage(data.author + ': ' + data.message)
    // });

    sendMessage.addEventListener("click", function (e) {
        // socket.emit('send', {
        //     "author": myName.value,
        //     "message": dataChannelSend.value,
        //     "room": ROOM
        // });
        //sendChannel.send(myName.value + " says " + dataChannelSend.value);
        e.preventDefault();
    }, false);
</script>